
#
# These sources are part of the "PyThon Programming Series" by Edgar Milvus, 
# you can find it on Amazon: https://www.amazon.com/dp/B0FTTQNXKG or
# https://tinyurl.com/PythonProgrammingSeries 
# New books info: https://linktr.ee/edgarmilvus 
#
# MIT License
# Copyright (c) 2025 Edgar Milvus
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Source File: theory_theoretical_foundations_part1.py
# Description: Theoretical Foundations
# ==========================================

from typing import Any, List, Tuple
import time
from google.genai import types

# Constants for the execution environment setup (Recommended dimensions)
SCREEN_WIDTH = 1440
SCREEN_HEIGHT = 900

def denormalize_x(x: int, screen_width: int) -> int:
    """
    Converts a normalized x coordinate (0-1000) generated by the Gemini model 
    into an actual pixel coordinate based on the screen width.
    
    This function implements the core scaling logic: 
    (Model X / 1000) * Actual Width.
    """
    return int(x / 1000 * screen_width)

def denormalize_y(y: int, screen_height: int) -> int:
    """
    Converts a normalized y coordinate (0-1000) generated by the Gemini model 
    into an actual pixel coordinate based on the screen height.
    
    This function implements the core scaling logic: 
    (Model Y / 1000) * Actual Height.
    """
    return int(y / 1000 * screen_height)

# The execute_function_calls function (simplified for theory) demonstrates 
# how the client code must parse the function call and apply denormalization 
# before executing the action via the automation library (e.g., Playwright).
# Note: In a live script, 'page' would be the Playwright page object.
def execute_function_calls(candidate, page, screen_width, screen_height):
    """
    Parses the model's response for function calls and executes the corresponding
    UI actions using the client-side handler.
    """
    results = []
    function_calls = []
    
    # Extract all function calls
    for part in candidate.content.parts:
        if part.function_call:
            function_calls.append(part.function_call)

    for function_call in function_calls:
        fname = function_call.name
        args = function_call.args
        print(f"  -> Executing: {fname}")

        try:
            if fname == "click_at":
                # Step 1: Denormalize coordinates
                actual_x = denormalize_x(args["x"], screen_width)
                actual_y = denormalize_y(args["y"], screen_height)
                
                # Step 2: Execute action (using the client library)
                # page.mouse.click(actual_x, actual_y) 
                print(f"    Click executed at pixel ({actual_x}, {actual_y})")
                
            elif fname == "type_text_at":
                actual_x = denormalize_x(args["x"], screen_width)
                actual_y = denormalize_y(args["y"], screen_height)
                text = args["text"]

                # page.mouse.click(actual_x, actual_y)
                # page.keyboard.type(text)
                print(f"    Typing '{text}' executed at pixel ({actual_x}, {actual_y})")

            # Wait for the environment to stabilize
            # page.wait_for_load_state(timeout=5000)
            time.sleep(1)

        except Exception as e:
            print(f"Error executing {fname}: {e}")
            
        results.append((fname, {"status": "success"}))
    return results

# A separate function must handle state capture and response formatting:
def get_function_responses(page, results):
    """
    Captures the new screenshot and formats the function responses 
    to be sent back to the model.
    """
    # screenshot_bytes = page.screenshot(type="png")
    # current_url = page.url
    
    # Simulation of capture:
    screenshot_bytes = b'PNG_DATA_SIMULATED'
    current_url = "https://example.com/new_page"
    
    function_responses = []
    for name, result in results:
        response_data = {"url": current_url}
        response_data.update(result)
        function_responses.append(
            types.FunctionResponse(
                name=name,
                response=response_data,
                parts=[types.FunctionResponsePart(
                        inline_data=types.FunctionResponseBlob(
                            mime_type="image/png",
                            data=screenshot_bytes))
                ]
            )
        )
    return function_responses
